(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{58:function(e,t,a){"use strict";a.r(t);var n=a(0),l=a.n(n);a(24);function r(e){return l.a.createElement("div",null,l.a.createElement("div",{class:"postHeader",style:{backgroundImage:"url(/img/"+e.headerImageUrl+")"}},l.a.createElement("h1",null,e.title)),l.a.createElement("div",{class:"photoAttribution"},"Header photo by ",l.a.createElement("a",{href:e.attributionUrl},e.attributionName)))}var i=a(136),o=a.n(i);t.default=function(){return l.a.createElement("div",null,l.a.createElement(r,{headerImageUrl:"simon-matzinger-twukN12EN7c-unsplash.jpg",title:"Clojure Coding Dojo",attributionName:"Simon Matzinger",attributionUrl:"https://unsplash.com/@8moments?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText"}),l.a.createElement("h2",null,"Setting the backdrop"),l.a.createElement("p",null,"I've been using Clojure for a little over three years and I finally made it to my first Clojure coding dojo at the London ThoughtWorks office a few weeks ago. I've wanted to attend one of these events for a while, but living outside of London has prevented me from doing so until now."),l.a.createElement("p",null,"I enjoyed the evening. If you haven't attended one of these events yet either, I would highly recommend trying to go to one. You can find out more about the ",l.a.createElement("a",{href:"https://www.meetup.com/London-Clojurians/"},"London Clojurians meetup group")," here."),l.a.createElement("hr",null),l.a.createElement("p",null,l.a.createElement("em",null,"I'd also like to make special mention of ",l.a.createElement("a",{href:"https://clojurebridge.org/"},"ClojureBridge"),' which "aims to increase diversity within the Clojure community by offering free, beginner-friendly Clojure programming workshops for underrepresented groups in tech." If you\'re in the London area and want to get involved, either as a student or as a coach, please checkout ',l.a.createElement("a",{href:"https://clojurebridgelondon.github.io/"},"ClojureBridge London"),".")),l.a.createElement("hr",null),l.a.createElement("h2",null,"Dojo structure"),l.a.createElement("p",null,"There is a lot of literature on the internet about running your own coding dojo so I won't go into detail here. The basic idea is to suggest a few problems to work on, vote on those to narrow the final selection, and then to split into smaller groups and work on a problem together. The final 30 minutes can be used for the groups to share what they may have learned during the session."),l.a.createElement("h2",null,"The challenge"),l.a.createElement("p",null,"I was in a group of three and we chose to work on solving the ",l.a.createElement("a",{href:"https://www.codewars.com/kata/snail"},"Codewars snail kata"),". When given an ",l.a.createElement("pre",null,"n x n")," array, your code has to return the array elements arranged from outermost elements to the centre element, traveling in a clockwise direction."),l.a.createElement("h2",null,"The code"),l.a.createElement("p",null,"The code that follows is what I implemented at home in the days after the dojo. It was based on my memories of what we attempted on the night. There may be some subtle differences, but the essence should be the same. You can checkout the code for this post at ",l.a.createElement("a",{href:"https://github.com/yogidevbear/clojure-playground/tree/master/snailsort"},"https://github.com/yogidevbear/clojure-playground/tree/master/snailsort"),"."),l.a.createElement("p",null,"We start by creating a new Clojure project using ",l.a.createElement("a",{href:"https://leiningen.org/"},"Leiningen"),". From the terminal, run:"),l.a.createElement("div",{class:"file-name"},"Terminal:"),l.a.createElement(o.a,{className:"plaintext"},"lein new snailsort"),l.a.createElement("p",null,"This creates a new project folder called ",l.a.createElement("pre",null,"snailsort")," with the following directory structure:"),l.a.createElement("div",{class:"file-name"},"Directory structure:"),l.a.createElement(o.a,{className:"plaintext"},"snailsort/",l.a.createElement("br",null),"  src/",l.a.createElement("br",null),"    snailsort/",l.a.createElement("br",null),"      core.clj",l.a.createElement("br",null),"  test/",l.a.createElement("br",null),"    snailsort/",l.a.createElement("br",null),"      core_test.clj",l.a.createElement("br",null),"  project.clj"),l.a.createElement("p",null,"Next, we change into the snailsort directory and start the tests using ",l.a.createElement("pre",null,"lein test-refresh"),"."),l.a.createElement(o.a,{className:"text"},"cd snailsort",l.a.createElement("br",null),"lein test-refresh"),l.a.createElement("p",null,"This should start running the code tests in the terminal. Every time we save any file in the ",l.a.createElement("pre",null,"test")," or ",l.a.createElement("pre",null,"src")," folders, the tests will be re-run automatically for us."),l.a.createElement("p",null,"We want to adhere to TDD. Using your editor of choice, open ",l.a.createElement("pre",null,"test/snailsort/core_test.clj"),". The ",l.a.createElement("pre",null,"snailsort.core-test")," namespace requires the ",l.a.createElement("pre",null,"snailsort.core")," namespace found in ",l.a.createElement("pre",null,"src/snailsort/core.clj"),". Update the ",l.a.createElement("pre",null,"require")," on lines 2-3 to alias ",l.a.createElement("pre",null,"snailsort.core")," as ",l.a.createElement("pre",null,"snail"),"."),l.a.createElement("div",{class:"file-name"},"test/snailsort/core_test.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(ns snailsort.core-test",l.a.createElement("br",null),"  (:require [clojure.test :refer :all]",l.a.createElement("br",null),"            [snailsort.core :as snail]))"),l.a.createElement("p",null,"This allows us to call functions within ",l.a.createElement("pre",null,"snailsort.core")," using syntax like ",l.a.createElement("pre",null,"(snail/some-function-name args)"),"."),l.a.createElement("p",null,"We decided on the evening that we would make use of array coordinates to reference positions within the array we were trying to sort. Let's define a 3x3 grid that we want to sort (as well as adding a commented out matrix to help us conceptualise the relative x+y coordinates while we work on the solution)."),l.a.createElement("div",{class:"file-name"},"test/snailsort/core_test.clj:"),l.a.createElement(o.a,{className:"Clojure"},"; Reference coordinates",l.a.createElement("br",null),";   x y",l.a.createElement("br",null),"; [[0 0] [0 1] [0 2]",l.a.createElement("br",null),";  [1 0] [1 1] [1 2]",l.a.createElement("br",null),";  [2 0] [2 1] [2 2]]",l.a.createElement("br",null),"",l.a.createElement("br",null),"(def grid",l.a.createElement("br",null),"  [[1 2 3]",l.a.createElement("br",null),"   [8 9 4]",l.a.createElement("br",null),"   [7 6 5]])"),l.a.createElement("p",null,"The initial path we took was to figure out how to traverse the grid. The first solution is sub-optimal, but I will run through it here first and then show a different approach towards the end which should illustrate what I mean."),l.a.createElement("p",null,"We have our grid above and we want to know how to find the next appropriate adjacent coordinate in our spiral sequence. We will define a ",l.a.createElement("pre",null,"next-coordinate")," function which will take a direction keyword and a current coordinate position. If we look at our commented reference grid above, we can see that our first coordinate on the top left is ",l.a.createElement("pre",null,"[0 0]")," and the next position to the ",l.a.createElement("pre",null,":right")," will be ",l.a.createElement("pre",null,"[0 1]"),". Using this logic we can start off by writing our first test with a few different assertions."),l.a.createElement("div",{class:"file-name"},"test/snailsort/core_test.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(deftest next-coordinate",l.a.createElement("br",null),'  (testing "Test retrieving next coordinate"',l.a.createElement("br",null),"    (is (= [0 1] (snail/next-coordinate :right [0 0])))",l.a.createElement("br",null),"    (is (= [2 1] (snail/next-coordinate :left [2 2])))",l.a.createElement("br",null),"    (is (= [2 2] (snail/next-coordinate :down [1 2])))",l.a.createElement("br",null),"    (is (= [1 0] (snail/next-coordinate :up [2 0])))))"),l.a.createElement("p",null,"Now we can add some code to our core namespace."),l.a.createElement("div",{class:"file-name"},"src/snailsort/core.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(def directions",l.a.createElement("br",null),"  {:right #(update-in % [1] inc)",l.a.createElement("br",null),"   :down #(update-in % [0] inc)",l.a.createElement("br",null),"   :left #(update-in % [1] dec)",l.a.createElement("br",null),"   :up #(update-in % [0] dec)})",l.a.createElement("br",null),"",l.a.createElement("br",null),"(defn next-coordinate",l.a.createElement("br",null),'  "I return the next grid coordinate based on current position and direction"',l.a.createElement("br",null),"  [direction current]",l.a.createElement("br",null),"  ((directions direction) current))"),l.a.createElement("p",null,"When you save these changes, you should see the tests refresh in your terminal, with an output similar to:"),l.a.createElement("div",{class:"file-name"},"Terminal:"),l.a.createElement(o.a,{className:"plaintext"},"*********************************************",l.a.createElement("br",null),"*************** Running tests ***************",l.a.createElement("br",null),":reloading (snailsort.core snailsort.core-test)",l.a.createElement("br",null),"",l.a.createElement("br",null),"Testing snailsort.core-test",l.a.createElement("br",null),"",l.a.createElement("br",null),"Ran 1 tests containing 4 assertions.",l.a.createElement("br",null),"0 failures, 0 errors.",l.a.createElement("br",null),"",l.a.createElement("br",null),"Passed all tests"),l.a.createElement("p",null,"I won't mention the test output again. The main point I'm hoping to illustrate is the quick feedback loop that you get from following this approach. Now back to the actual code above."),l.a.createElement("p",null,"The first thing we did, was define a Clojure map call ",l.a.createElement("pre",null,"directions"),". This will map each of the four direction keywords to a relative function for updating the ",l.a.createElement("pre",null,"[x y]")," coordinates that we're trying to keep track of as we step through solving the grid path."),l.a.createElement("p",null,"In the example of calling ",l.a.createElement("pre",null,"(next-coordinate :right [0 0])"),", this will resolve to ",l.a.createElement("pre",null,"((directions :right) [0 0])")," which will ultimately resolve to ",l.a.createElement("pre",null,"(#(update-in % [1] inc) [0 0])"),", which will return ",l.a.createElement("pre",null,"[0 1]"),"."),l.a.createElement("p",null,"I'm sure by now, you're already noting that we need to check that the coordinate we're returning is _actually_ valid. We don't want to get into a situation where we're going outside the possible confines of our grid."),l.a.createElement("p",null,"Let's go back and write our next test to check if an ",l.a.createElement("pre",null,"[x y]")," coordinate is valid."),l.a.createElement("div",{class:"file-name"},"test/snailsort/core_test.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(deftest is-valid?",l.a.createElement("br",null),'  (testing "Test if next coordinate is valid"',l.a.createElement("br",null),"    (is (= true (snail/is-valid? grid [0 2])))",l.a.createElement("br",null),"    (is (= true (snail/is-valid? grid [1 1])))",l.a.createElement("br",null),"    (is (= false (snail/is-valid? grid [0 3])))",l.a.createElement("br",null),"    (is (= false (snail/is-valid? grid [0 3])))))"),l.a.createElement("p",null,"We are testing two positions that we know will be valid and two which won't be. Next we can switch to our core namespace and write the function to pass the test."),l.a.createElement("div",{class:"file-name"},"src/snailsort/core.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(defn is-valid?",l.a.createElement("br",null),'  "I return a boolean if a coordinate is valid or not"',l.a.createElement("br",null),"  [grid coordinate]",l.a.createElement("br",null),"  (some? (get-in grid coordinate)))"),l.a.createElement("p",null,"This function is pretty straightforward. We're just checking if we can return a value from our grid by using ",l.a.createElement("pre",null,"get-in")," with our ",l.a.createElement("pre",null,"[x y]")," coordinate."),l.a.createElement("p",null,"We have a way to get an adjacent position and a way to test for valid positions. Next, we need a way to determine our next clockwise direction for when we need to switch things up. Here is the test:"),l.a.createElement("div",{class:"file-name"},"test/snailsort/core_test.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(deftest next-direction",l.a.createElement("br",null),'  (testing "Test next-direction for clockwise rotation"',l.a.createElement("br",null),"    (is (= :down (snail/next-direction :right)))",l.a.createElement("br",null),"    (is (= :left (snail/next-direction :down)))",l.a.createElement("br",null),"    (is (= :up (snail/next-direction :left)))",l.a.createElement("br",null),"    (is (= :right (snail/next-direction :up)))))"),l.a.createElement("p",null,"And the code to solve it (note that we need a map to help with the clockwise step):"),l.a.createElement("div",{class:"file-name"},"src/snailsort/core.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(def clockwise-direction",l.a.createElement("br",null),"  {:right :down",l.a.createElement("br",null),"   :down :left",l.a.createElement("br",null),"   :left :up",l.a.createElement("br",null),"   :up :right})",l.a.createElement("br",null),"",l.a.createElement("br",null),"(defn next-direction",l.a.createElement("br",null),'  "I return the next clockwise direction"',l.a.createElement("br",null),"  [direction]",l.a.createElement("br",null),"  (direction clockwise-direction))"),l.a.createElement("p",null,"Our next logical step is to check that we haven't visited a position before. We can write a function that takes a set of previously visited positions and the coordinate we want to test and return ",l.a.createElement("pre",null,"true")," if it isn't found in the set."),l.a.createElement("div",{class:"file-name"},"test/snailsort/core_test.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(deftest first-visit?",l.a.createElement("br",null),'  (testing "Test if coordinate is being visited for the first time"',l.a.createElement("br",null),"    (is (= true (snail/first-visit? #{} [0 0])))",l.a.createElement("br",null),"    (is (= false (snail/first-visit? #{[0 0]} [0 0])))",l.a.createElement("br",null),"    (is (= true (snail/first-visit? #{[0 0] [0 1]} [0 2])))",l.a.createElement("br",null),"    (is (= false (snail/first-visit? #{[0 0] [0 1] [0 2]} [0 2])))))"),l.a.createElement("div",{class:"file-name"},"src/snailsort/core.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(defn first-visit?",l.a.createElement("br",null),'  "I check if a grid cell is being checked for the first time"',l.a.createElement("br",null),"  [checked current]",l.a.createElement("br",null),"  (nil? ((set checked) current)))"),l.a.createElement("p",null,"We also want to know if we've completed traversing the grid."),l.a.createElement("div",{class:"file-name"},"test/snailsort/core_test.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(deftest all-visits?",l.a.createElement("br",null),'  (testing "Test if visited set size matches grid size"',l.a.createElement("br",null),"    (is (= false (snail/all-visits? grid #{[0 0]})))",l.a.createElement("br",null),"    (is (= false (snail/all-visits? grid #{[0 0] [0 1]})))",l.a.createElement("br",null),"    (is (= true (snail/all-visits? grid #{[0 0] [0 1] [0 2] [1 0] [1 1] [1 2] [2 0] [2 1] [2 2]})))",l.a.createElement("br",null),"    (is (= true (snail/all-visits? grid #{[0 0] [0 1] [0 2] [1 2] [2 2] [2 1] [2 0] [1 0] [1 1]})))))"),l.a.createElement("div",{class:"file-name"},"src/snailsort/core.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(defn all-visits?",l.a.createElement("br",null),'  "I check if all grid cells have been checked"',l.a.createElement("br",null),"  [grid checked]",l.a.createElement("br",null),"  (= (count (flatten grid))",l.a.createElement("br",null),"     (count checked)))"),l.a.createElement("p",null,"The above few functions give us most of the pieces we need for validation purposes. Let's switch things up and start working towards solving the path we want to traverse."),l.a.createElement("hr",null),l.a.createElement("p",null,"NOTE:",l.a.createElement("br",null),l.a.createElement("em",null,"It was at this point where I was working at home on the remainder of the solution by myself. At the time, I was wondering whether there was a more idiomatic solution that could be used instead. Although the code we have so far is well tested and makes a lot of sense, it is also growing a little unwieldy. For the purposes of this article though, I'll continue with the current solution and come back to a more succinct solution at the end.")),l.a.createElement("hr",null),l.a.createElement("p",null,"The next logical step in the current approach is to figure out which is the next valid position to traverse. We need to know if we can keep going in the current direction or whether we need to turn clockwise, etc. There are a few test assertions we can use here to cover all our bases."),l.a.createElement("div",{class:"file-name"},"test/snailsort/core_test.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(deftest next-valid-coordinate",l.a.createElement("br",null),'  (testing "Test next valid position in grid"',l.a.createElement("br",null),"    (is (= {:direction :right :next-coordinate [0 1]} (snail/next-valid-coordinate grid [0 0] :right #{[0 0]})))",l.a.createElement("br",null),"    (is (= {:direction :left :next-coordinate [2 1]} (snail/next-valid-coordinate grid [2 2] :down #{[0 0] [0 1] [0 2] [1 2] [2 2]})))",l.a.createElement("br",null),"    (is (= {:direction :up :next-coordinate [1 0]} (snail/next-valid-coordinate grid [2 0] :left #{[0 0] [0 1] [0 2] [1 2] [2 2] [2 1] [2 0]})))",l.a.createElement("br",null),"    (is (= {:direction :right :next-coordinate [1 1]} (snail/next-valid-coordinate grid [1 0] :up #{[0 0] [0 1] [0 2] [1 2] [2 2] [2 1] [2 0] [1 0]})))",l.a.createElement("br",null),"    (is (= nil (snail/next-valid-coordinate grid [1 1] :down #{[0 0] [0 1] [0 2] [1 2] [2 2] [2 1] [2 0] [1 0] [1 1]})))))"),l.a.createElement("div",{class:"file-name"},"src/snailsort/core.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(defn next-valid-coordinate",l.a.createElement("br",null),'  "I return the next valid coordinate or nil if none exists"',l.a.createElement("br",null),"  [grid current direction checked]",l.a.createElement("br",null),"  (let [next-pos (next-coordinate direction current)",l.a.createElement("br",null),"        new-direction (next-direction direction)",l.a.createElement("br",null),"        rotated-pos (next-coordinate new-direction current)]",l.a.createElement("br",null),"    (if (and (is-valid? grid next-pos)",l.a.createElement("br",null),"             (first-visit? checked next-pos))",l.a.createElement("br",null),"      {:direction direction :next-coordinate next-pos}",l.a.createElement("br",null),"      (if (and (is-valid? grid rotated-pos)",l.a.createElement("br",null),"               (first-visit? checked rotated-pos))",l.a.createElement("br",null),"        {:direction new-direction :next-coordinate rotated-pos}",l.a.createElement("br",null),"        nil))))"),l.a.createElement("p",null,"The idea of ",l.a.createElement("pre",null,"next-valid-coordinate")," is to return a map of the next position, _as well as_ the direction for the next test. We need to return the direction in the result as we need to be made aware of any potential change in direction."),l.a.createElement("p",null,"One thing we haven't covered yet, and is a requirement for the kata, is to validate that the grid being supplied is actually a valid square."),l.a.createElement("p",null,"We want to test a variety of valid grid sizes, so lets start with a function in our test file to generate grids of any specified length."),l.a.createElement("div",{class:"file-name"},"test/snailsort/ore_test.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(defn generate-grid",l.a.createElement("br",null),'  "Generates a random n x n grid"',l.a.createElement("br",null),"  [n]",l.a.createElement("br",null),"  (if (< n 1)",l.a.createElement("br",null),"    [[]]",l.a.createElement("br",null),"    (let [row (fn [] (take n (repeatedly #(rand-int 10))))]",l.a.createElement("br",null),"      (into [] (take n (repeatedly #(into [] (row))))))))"),l.a.createElement("p",null,"Now we can define our test and function to check if a grid is a valid square."),l.a.createElement("div",{class:"file-name"},"test/snailsort/ore_test.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(deftest is-valid-grid?",l.a.createElement("br",null),'  (testing "Test if grid supplied is valid n x n square"',l.a.createElement("br",null),"    (is (= false (snail/is-valid-grid? [])))",l.a.createElement("br",null),"    (is (= false (snail/is-valid-grid? [1 2 3])))",l.a.createElement("br",null),"    (is (= false (snail/is-valid-grid? [[1 2 3] [4 5 6]])))",l.a.createElement("br",null),"    (is (= false (snail/is-valid-grid? [[1 2 3] [4 5] [6 7 8 9]])))",l.a.createElement("br",null),"    (is (= true (snail/is-valid-grid? grid)))",l.a.createElement("br",null),"    (is (= true (snail/is-valid-grid? (generate-grid 0))))",l.a.createElement("br",null),"    (is (= true (snail/is-valid-grid? (generate-grid 3))))",l.a.createElement("br",null),"    (is (= true (snail/is-valid-grid? (generate-grid 9))))",l.a.createElement("br",null),"    (is (= true (snail/is-valid-grid? (generate-grid 100))))",l.a.createElement("br",null),"    (is (= true (snail/is-valid-grid? (generate-grid 1000))))))"),l.a.createElement("div",{class:"file-name"},"src/snailsort/core.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(defn is-valid-grid?",l.a.createElement("br",null),'  "I check if a supplied grid is a valid n x n grid"',l.a.createElement("br",null),"  [grid]",l.a.createElement("br",null),"  (if (= grid [[]])",l.a.createElement("br",null),"    true",l.a.createElement("br",null),"    (let [height (count grid)]",l.a.createElement("br",null),"      (if (> height 0)",l.a.createElement("br",null),"        (every? #{true}",l.a.createElement("br",null),"                (map #(and (= (type %) (type []))",l.a.createElement("br",null),"                           (= height (count %)))",l.a.createElement("br",null),"                     grid))",l.a.createElement("br",null),"        false))))"),l.a.createElement("p",null,"We have most of the parts we need for a final solution. The approach that I initially went for was to work out the sequence as a list of cooridates and then use that sequence to fetch the individual position values. First we need the function to work out the sequence. For this, we can also add a couple of other variations of grids to test, followed by the sequence function test."),l.a.createElement("div",{class:"file-name"},"test/snailsort/ore_test.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(def grid-alt-1",l.a.createElement("br",null),"  [[1 2]",l.a.createElement("br",null),"   [4 3]])",l.a.createElement("br",null),"",l.a.createElement("br",null),"(def grid-alt-2",l.a.createElement("br",null),"  [[1 2 3 4 5]",l.a.createElement("br",null),"   [16 17 18 19 6]",l.a.createElement("br",null),"   [15 24 25 20 7]",l.a.createElement("br",null),"   [14 23 22 21 8]",l.a.createElement("br",null),"   [13 12 11 10 9]])",l.a.createElement("br",null),"",l.a.createElement("br",null),"(deftest sequence-path",l.a.createElement("br",null),'  (testing "Test if sequence-path returns the correct vector sequence of coordinate points of snailsort"',l.a.createElement("br",null),"    (is (= [[0 0] [0 1] [0 2] [1 2] [2 2] [2 1] [2 0] [1 0] [1 1]] (snail/sequence-path grid)))",l.a.createElement("br",null),"    (is (= [[0 0] [0 1] [1 1] [1 0]] (snail/sequence-path grid-alt-1)))",l.a.createElement("br",null),"    (is (= [[0 0] [0 1] [0 2] [0 3] [0 4] [1 4] [2 4] [3 4] [4 4] [4 3] [4 2] [4 1] [4 0] [3 0] [2 0] [1 0] [1 1] [1 2] [1 3] [2 3] [3 3] [3 2] [3 1] [2 1] [2 2]] (snail/sequence-path grid-alt-2)))))"),l.a.createElement("div",{class:"file-name"},"src/snailsort/core.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(defn sequence-path",l.a.createElement("br",null),'  "I return a vector of the spiral path"',l.a.createElement("br",null),"  ([grid]",l.a.createElement("br",null),"   (sequence-path grid [] [0 0] :right))",l.a.createElement("br",null),"  ([grid res current direction]",l.a.createElement("br",null),"   (let [res (conj res current)]",l.a.createElement("br",null),"     (if (< (count res) (count (flatten grid)))",l.a.createElement("br",null),"       (let [next-valid (next-valid-coordinate grid current direction res)]",l.a.createElement("br",null),"         (recur grid res (:next-coordinate next-valid) (:direction next-valid)))",l.a.createElement("br",null),"       res))))"),l.a.createElement("p",null,"I've used a 2-arity function definition here so that we can simply pass in the grid and let the known defaults initialise the main recursive functionality. With each iteration, we conjoin the current position to the result. We then check if the result has the same number of coordinates as positions in the main grid. If it is smaller, we recall (",l.a.createElement("pre",null,"recur"),") the function with the result and the next coorditate. If the result is the same size as the grid, then we can return the result."),l.a.createElement("p",null,"We have everything we need now, so let's implement the main snailsort function."),l.a.createElement("div",{class:"file-name"},"test/snailsort/ore_test.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(deftest snailsort",l.a.createElement("br",null),'  (testing "Test snailsort function"',l.a.createElement("br",null),"    (is (= [] (snail/snailsort [[]])))",l.a.createElement("br",null),"    (is (= (mapv inc (range 9)) (snail/snailsort grid)))",l.a.createElement("br",null),"    (is (= (mapv inc (range 4)) (snail/snailsort grid-alt-1)))",l.a.createElement("br",null),"    (is (= (mapv inc (range 25)) (snail/snailsort grid-alt-2)))",l.a.createElement("br",null),"    (is (= [1 2 3 6 9 8 7 4 5] (snail/snailsort [[1 2 3] [4 5 6] [7 8 9]])))))"),l.a.createElement("div",{class:"file-name"},"src/snailsort/core.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(defn snailsort",l.a.createElement("br",null),'  "I sort an n x n grid in a clockwise spiral pattern"',l.a.createElement("br",null),"  [grid]",l.a.createElement("br",null),"  (if (is-valid-grid? grid)",l.a.createElement("br",null),"    (if (= grid [[]])",l.a.createElement("br",null),"      []",l.a.createElement("br",null),"      (let [spiral-path (sequence-path grid)]",l.a.createElement("br",null),"        (mapv #(get-in grid %) spiral-path)))",l.a.createElement("br",null),"    nil))"),l.a.createElement("p",null,"And there you have it. A ",l.a.createElement("pre",null,"snailsort")," function that we can call with a grid which will return the expected result for a valid grid or ",l.a.createElement("pre",null,"nil")," for a bogus grid."),l.a.createElement("h2",null,"Improving the solution"),l.a.createElement("p",null,"As you can see, the solution works, but is rather lengthly. I was chatting to a friend who's work colleague, Corneliu Hoffmann, created a solution using the concept of rotating the grid as opposed to trying to walk the grid sequentially. I spent a bit of time thinking about this and decided to try my own implementation using this concept."),l.a.createElement("h3",null,"Understanding the rotation"),l.a.createElement("p",null,"Assume we have the following grid:"),l.a.createElement(o.a,{className:"Clojure"},"[[1 2 3]",l.a.createElement("br",null)," [4 5 6]",l.a.createElement("br",null)," [7 8 9]]"),l.a.createElement("p",null,"I want to be able to have a result of ",l.a.createElement("pre",null,"[1 2 3 6 9 8 7 4 5]")," for my sorted result. I can take the first row (i.e. ",l.a.createElement("pre",null,"[1 2 3]"),") in order to start my result. This will leave me with the rest."),l.a.createElement(o.a,{className:"Clojure"},"[[4 5 6]",l.a.createElement("br",null)," [7 8 9]]"),l.a.createElement("p",null,"Now for the rotation, we want to convert the above into a new structure, namely:"),l.a.createElement(o.a,{className:"Clojure"},"[[6 9]",l.a.createElement("br",null)," [5 8]",l.a.createElement("br",null)," [4 7]]"),l.a.createElement("p",null,"Then I can take the first row from that (i.e. ",l.a.createElement("pre",null,"[6 9]"),") and join it to my current result (i.e. ",l.a.createElement("pre",null,"[1 2 3 6 9]"),") which will leave me with the rest."),l.a.createElement(o.a,{className:"Clojure"},"[[5 8]",l.a.createElement("br",null)," [4 7]]"),l.a.createElement("p",null,"And then we repeat the process until there is nothing left. At that point, we can return our result."),l.a.createElement("h3",null,"What does it look like?"),l.a.createElement("p",null,"Here is my attempt at this solution."),l.a.createElement("div",{class:"file-name"},"src/snailsort/core.clj:"),l.a.createElement(o.a,{className:"Clojure"},"(defn rotation-sort",l.a.createElement("br",null),'  "An alternative solution to snailsort."',l.a.createElement("br",null),"  [grid]",l.a.createElement("br",null),"  (when (is-valid-grid? grid)",l.a.createElement("br",null),"    (loop [acc []",l.a.createElement("br",null),"           coll grid]",l.a.createElement("br",null),"      (if (empty? coll)",l.a.createElement("br",null),"        (flatten acc)",l.a.createElement("br",null),"        (recur (conj acc (first coll))",l.a.createElement("br",null),"               (partition (count (rest coll))",l.a.createElement("br",null),"                          (apply interleave",l.a.createElement("br",null),"                                 (map reverse (rest coll)))))))))"),l.a.createElement("p",null,"I think this solution is really interesting. We can get rid of most of the functions we wrote previously. The only two functions we need are the one above, and ",l.a.createElement("pre",null,"is-valid-grid?")," because we still want to validate our input before attempting to sort it. This example shows how a change in perspective can have a significant impact on the approach we end up taking."),l.a.createElement("h2",null,"Conclusion"),l.a.createElement("p",null,"I hope you enjoyed reading this post. Hopefully you learned something new along the way. I learned a few things by attending the Clojure coding dojo and working through this solution at home afterwards. I would like to encourage anyone reading this to attend a coding dojo in whichever programming language(s) you're interested in. It's a great way to meet like-minded people and learn new things. I'll definitely be attending more of them myself in the near future."))}}}]);